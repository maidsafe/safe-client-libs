stage('build') {
    parallel real: {
        node('docker_slave-centos-7.5-x86_64') {
            git([url: env.REPO_URL, branch: 'docker_build'])
            clean()
            build_safe_client_libs('real')
            commit_container_artifacts('real')
        }
    },
    mock: {
        node('docker_slave-centos-7.5-x86_64') {
            git([url: env.REPO_URL, branch: 'docker_build'])
            clean()
            build_safe_client_libs('mock')
            commit_container_artifacts('mock')
            upload_binary_compatibility_test()
        }
    }
}

stage('test') {
    parallel mocked: {
        node('docker_slave-centos-7.5-x86_64') {
            run_mocked_tests()
        }
    },
    integration: {
        node('docker_slave-centos-7.5-x86_64') {
            run_integration_tests()
        }
    },
    binary: {
        node('docker_slave-centos-7.5-x86_64') {
            run_binary_compatibility_tests()
        }
    }
}

stage('packaging') {
    node('docker_slave-centos-7.5-x86_64') {
        for (app in ['safe_app', 'safe_authenticator']) {
            run_packaging(app)
        }
        move_packages_to_deploy()
    }
}

stage('deployment') {
    node('docker_slave-centos-7.5-x86_64') {
        withAWS(credentials: 'aws_jenkins_user_credentials', region: 'eu-west-2') {
            def artifacts = sh(returnStdout: true, script: 'ls -1 deploy').trim().split("\\r?\\n")
            for (artifact in artifacts) {
                s3Upload(
                    bucket: 'safe-client-libs-jenkins',
                    file: artifact,
                    workingDir: "${env.WORKSPACE}/deploy",
                    acl: 'PublicRead')
            }
        }
    }
}

stage('clean') {
    node('docker_slave-centos-7.5-x86_64') {
        clean()
    }
}

def clean() {
    clean_build_containers()
    def mock_tag = get_tag_from_full_image_name(get_committed_build_image_name('mock'))
    def real_tag = get_tag_from_full_image_name(get_committed_build_image_name('real'))
    // Unfortunately you can't seem to split this long string over multiple lines.
    sh($/eval "docker images | grep -E '${mock_tag}|${real_tag}' | awk '{ print \$3 }' | xargs docker rmi || true" /$)
    sh("rm -f *.zip")
    sh("rm -rf deploy")
}

def clean_build_containers() {
    for (mode in ['mock', 'real']) {
        def container_name = get_container_name(mode, 'build')
        sh("docker rm ${container_name} || true")
    }
}

def get_user_details() {
    def user_id = sh(returnStdout: true, script: 'echo $UID').trim()
    def group_id = sh(
        returnStdout: true,
        script: $/eval 'getent group $USER | awk -F : "{ print \$3 }"'/$).trim()
    return [user_id, group_id]
}

def get_tag_from_full_image_name(image_name) {
    return image_name.drop(image_name.indexOf(':') + 1)
}

def get_committed_build_image_name(mode) {
    // There will only be 2 images created, 'real' and 'mock'.
    // The binary and integration tests will both use the mock image, since all the builds
    // they need will be committed in the mock image.
    def m = mode == 'integration' || mode == 'binary' ? 'mock' : mode
    def tag = "build-${m}-${env.BUILD_NUMBER}"
    return "${env.IMAGE_NAME}:${tag}"
}

def build_safe_client_libs(mode) {
    def user_details = get_user_details()
    def user_id = user_details[0]
    def group_id = user_details[1]
    def image_name = "${env.IMAGE_NAME}:${env.IMAGE_TAG}"
    def container_name = get_container_name(mode, 'build')
    sh("docker run --name ${container_name} " +
       "-v ${env.WORKSPACE}:${env.MOUNT_POINT}:Z " +
       "-u ${user_id}:${group_id} " +
       "${image_name} scripts/build-${mode}")
}

def upload_binary_compatibility_test() {
    def container_name = get_container_name('mock', 'build')
    sh("mkdir -p ${env.WORKSPACE}/bct/${env.BUILD_NUMBER}")
    sh("docker cp ${container_name}:/target/release .")
    def test_executable = sh(
        returnStdout: true,
        script: $/eval "find release -maxdepth 1 -mindepth 1 -name 'tests-*' ! -name '*.d'" /$).trim()
    sh("cp ${test_executable} ${env.WORKSPACE}/bct/${env.BUILD_NUMBER}/tests")
    sh("rm -rf release")
    withAWS(credentials: 'aws_jenkins_user_credentials', region: 'eu-west-2') {
        s3Upload(
            bucket: 'safe-client-libs-jenkins',
            file: "bct/${env.BUILD_NUMBER}/tests",
            path: "bct/${env.BUILD_NUMBER}/tests",
            workingDir: "${env.WORKSPACE}",
            acl: 'PublicRead')
    }
}

def get_container_name(mode, type, app='') {
    if (app?.trim()) {
        return "safe_client_libs_${app}_${mode}_${type}_${env.BUILD_NUMBER}"
    }
    return "safe_client_libs_${mode}_${type}_${env.BUILD_NUMBER}"
}

def commit_container_artifacts(mode) {
    def container_name = get_container_name(mode, 'build')
    def container_id = sh(
        returnStdout: true,
        script: $/eval "docker ps -a | grep -w '${container_name}' | awk '{ print \$1 }'" /$).trim()
    def image_name = get_committed_build_image_name(mode)
    sh("docker commit ${container_id} ${image_name}")
}

def run_mocked_tests() {
    run_tests('mock')
}

def run_integration_tests() {
    run_tests('integration')
}

def run_binary_compatibility_tests() {
    build_number = get_last_successful_build_number(currentBuild)
    if (build_number != -1) {
        echo("Running binary compatibility tests: build ${build_number} being used as previous set")
        bct_test_path = "${env.WORKSPACE}/bct-${build_number}"
        withAWS(credentials: 'aws_jenkins_user_credentials', region: 'eu-west-2') {
            s3Download(
                file: "${bct_test_path}",
                bucket: 'safe-client-libs-jenkins',
                path: "bct/${build_number}/tests",
                force: true)
        }
        run_tests('binary', bct_test_path)
    } else {
        echo("Not running binary compatibility tests:  no previously successful builds found")
    }
}

def run_tests(mode, bct_test_path='') {
    def user_details = get_user_details()
    def user_id = user_details[0]
    def group_id = user_details[1]
    def image_name = get_committed_build_image_name(mode)
    def container_name = get_container_name(mode, 'test_run')
    def command = "docker run --rm --name ${container_name} " +
        "-v ${env.WORKSPACE}:${env.MOUNT_POINT}:Z " +
        "-e CARGO_TARGET_DIR=/target " +
        "-u ${user_id}:${group_id} "
    if (mode == 'binary') {
        command += "-v ${bct_test_path}:/bct/tests:Z "
        command += "-e COMPAT_TESTS=/bct/tests "
    }
    command += "${image_name} scripts/test-${mode}"
    sh(command)
}

def run_packaging(app) {
    def user_details = get_user_details()
    def user_id = user_details[0]
    def group_id = user_details[1]
    for (mode in ['real', 'mock']) {
        def image_name = get_committed_build_image_name(mode)
        def container_name = get_container_name(mode, 'package', app)
        def command = "docker run --rm --name ${container_name} " +
            "-v ${env.WORKSPACE}:${env.MOUNT_POINT}:Z " +
            "-e CARGO_TARGET_DIR=/target " +
            "-u ${user_id}:${group_id} " +
            "${image_name} scripts/package.rs --lib --name ${app} --commit"
        if (mode == 'mock') {
            command += " --mock"
        }
        sh(command)
    }
}

def move_packages_to_deploy() {
    sh('mkdir deploy')
    sh('mv *.zip deploy')
}

def get_last_successful_build_number(build) {
    if (build == null) {
        return -1
    }
    if (build.result == 'SUCCESS') {
        return build.number as Integer
    }
    return get_last_successful_build_number(build.getPreviousBuild())
}
